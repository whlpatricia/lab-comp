#!/usr/bin/env python3

# This program processes an address trace generated by the Valgrind lackey tool
# to create a reduced trace according to the Fastslim-Demand algorithm 
# described in "FastSlim: prefetch-safe trace reduction for I/O cache 
# simulation" by Wei Jin, Xiaobai Sun, and Jeffrey S. Chase in ACM Transactions
# on  Modeling and Computer Simulation, Vol. 11, No. 2 (April 2001), 
# pages 125-160. http://doi.acm.org/10.1145/384169.384170

import argparse
import fileinput
import operator
import sys


class TraceItem(object):
	def __init__(self, reftype, pg, tstamp):
		self.reftype = reftype
		self.pg = pg
		self.tstamp = tstamp
		self.marked = False

	def __eq__(self, other):
		return self.pg == other.pg

	def __repr__(self):
		return "{} {:x}".format(self.reftype, self.pg * 4096)

	def __hash__(self):
		return hash(self.pg)


ts = 0               # "timestamp" (entry number in original trace)
tracebuffer = set()  # The set of entries in the buffer
toprint = []         # The list of entries waiting to be printed in order

# Emit in timestamp order may have to hold onto items until the trace buffer
# is emptied, because there may be marked items in the trace buffer with 
# earlier timestamps that have to appear in the output first. 
# So, we put entries into a list as they are first seen and then 
# emit_marked adds all marked items to the list. 
# The list is then sorted by timestamp and printed.
def emit_marked_in_ts_order():
	for ti in tracebuffer:
		if ti.marked:
			toprint.append(ti)
	toprint.sort(key=operator.attrgetter("tstamp"))
	for ti in toprint:
		print(ti)
	tracebuffer.clear()
	toprint.clear()

# Parse command line arguments
parser = argparse.ArgumentParser(description="Reduce address trace from valgrind using fastslim-demand algorithm.")
parser.add_argument("-k", "--keepcode", action="store_true", help="include code pages in compressed trace")
parser.add_argument("-b", "--buffersize", type=int, default=4, help="number of entries in trace buffer")
parser.add_argument("tracefile", nargs='?', default='-')
args = parser.parse_args()

# Process input trace
for line in fileinput.input(args.tracefile):
	if line[0] == '=':
		continue

	tokens = line.strip().split()
	reftype = tokens[0]
	addr = int(tokens[1].split(',')[0], 16)

	if not args.keepcode and (reftype == 'I'):
		continue
	pg = addr // 4096
	ti = TraceItem(reftype, pg, ts)

	if ti in tracebuffer:
		ti.marked = True
		ti.tstamp = ts
	else:
		if (len(tracebuffer) == args.buffersize):
			emit_marked_in_ts_order()
		toprint.append(ti)
		tracebuffer.add(ti)
	ts = ts + 1

emit_marked_in_ts_order()
